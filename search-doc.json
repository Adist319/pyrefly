[{"title":"Documentation","type":0,"sectionRef":"#","url":"/en/docs/","content":"Documentation Guides and references for all you need to know about Pyrefly. üìÑÔ∏è Introduction Never used a type system before or just new to Pyrefly? Start here! üìÑÔ∏è Learn Python Typing Get to know Python's Type System with working examples üìÑÔ∏è Error Kinds Pyrefly error categories and suppression codes üìÑÔ∏è Import Resolution How Pyrefly finds and resolves imports","keywords":"","version":"Next"},{"title":"Pyrefly Configuration","type":0,"sectionRef":"#","url":"/en/docs/configuration/","content":"","keywords":"","version":"Next"},{"title":"Precedence in Options‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#precedence-in-options","content":" The following is the order in which configuration options are selected:  CLI flagEnvironment variable override -- This is the same as PYREFLY_&lt;CLI flag name&gt;Configuration optionHard-coded default  ","version":"Next","tagName":"h2"},{"title":"Configuration Finding‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-finding","content":" In both project checking mode (with no explicit configuration supplied) and single-file checking mode, we perform an upward file search to find a configuration file. We check each directory from the start location to the filesystem root, looking first for pyrefly.toml then pyproject.toml, in the same directory before looking at its parent.  For project checking mode, the start location is the CWD. We do not perform any searching if the --config/-c flag is used. For single-file checking mode, the start location is the directory containing the file to be type checked. No config flag can be passed into Pyrefly in single file checking mode.  If a pyrefly.toml is found, it is parsed and used for type checking, and will return an error to the user on invalid types, syntax, or values.  If a pyproject.toml is found, Pyrefly will stop searching, even if no [tool.pyrefly]section is found. The same errors will be returned as when loading a pyrefly.toml if the config is invalid.  ","version":"Next","tagName":"h2"},{"title":"Configuration Options‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-options","content":" project_includes: the glob patterns used to describe which files to type check, typically understood as user-space files. This takes highest precedence in import resolution. Type: list of Unix Glob patternsDefault: [&quot;**/*.py&quot;]Flag equivalent: FILES... argumentEquivalent configs: include in Pyright, files/modules/packages in mypyNotes: When overridden by passing in FILES..., we do not consult the relevant config file for what to use for project_excludes. Ifproject_excludes should not use the default value, override it with the flag as well.When a project_includes pattern does not match any files, we will return an error. project_excludes: the glob patterns used to describe which files to avoid type checking, usually as a more fine-grained way of controlling the files you get type errors on. Type: list of Unix Glob patternsDefault: [&quot;**/__pycache__/**&quot;, &quot;**/.*&quot;]Flag equivalent: --project-excludesEquivalent configs: exclude in Pyright and mypyNotes: We match on these patterns, unlike project_includes, where we enumerate all (Python) files under the directory. Because of this,project_excludes does not do directory matching unless a / is added at the end of your glob pattern. **/__pycache__/ will only match files under a directory named __pycache__/, but not a file named __pycache__. Likewise, **/__pycache__ will only match files named __pycache__, but not files under a directory named __pycache__/.It is an error if no files are returned from any project_includes because they are filtered out by project_excludes entries.When passing in FILES..., we also do not consult the config file for what to use for project_excludes. If project_excludes should not use the default value, override it with a flag as well. search_path: a file path describing a root from which imports should be found and imported from (including modules in project_includes). This takes the highest precedence in import order, before typeshed andsite_package_path. When a project_includes type checked file is imported by another type checked file, we check all search roots to determine how to import it. Type: list of directoriesDefault: [&quot;.&quot;]Flag equivalent: --search-pathENV equivalent: PYREFLY_SEARCH_PATHEquivalent configs: extraPaths in Pyright, mypy_path in mypyNotes: we automatically append &quot;.&quot; (the directory containing the configuration file) to the search_roots when type checking as a sensible default and last attempt at an import. site_package_path: a file path describing a root from which imports should be found and imported from. This takes the lowest priority in import resolution, after project_includes, typeshed, and search_roots. Type: list of directoriesDefault: result from Environment Autoconfiguration or []Flag equivalent: --site-package-pathENV equivalent: PYREFLY_SITE_PACKAGE_PATHEquivalent configs: none python_platform: the value used with conditions based on type checking againstsys.platformvalues. Type: stringDefault: result from Environment Autoconfiguration or &quot;linux&quot;Flag equivalent: --python-platformENV equivalent: PYREFLY_PYTHON_PLATFORMEquivalent configs: pythonPlatform in Pyright, platform in mypy python_version: the value used with conditions based on type checking againstsys.versionvalues. The format should be &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]], where minor and micro can be omitted to take the default positional value. Type: stringDefault: result from Environment Autoconfiguration or 3.13.0Flag equivalent: --python-versionENV equivalent: PYREFLY_PYTHON_VERSIONEquivalent configs: pythonVersion in Pyright, python_version in mypy python_interpreter: the Python interpreter to query when attempting to autoconfigure Python environment values (site_package_path, python_platform, python_version). See the Environment Autoconfiguration section for more information. Type: string of executable or path to executableDefault: python3Flag equivalent: --python-interpreterENV equivalent: PYREFLY_PYTHON_INTERPRETEREquivalent configs: python_executable in mypyNotes: This executes the value present in the python_interpreter field without any checks. It could be a security risk if your python_interpreter executes an arbitrary executable.If you are working on a project shared between multiple people, it is likely best not to use this option, since there might be different Python interpreter versions used on different systems. Instead, we recommend explicitly setting python_version, python_platform, and site_package_path, or using alternative methods of environment autoconfiguration (coming soon). errors: configure (enable and disable) the errors Pyrefly shows Type: Table of error code name to boolean representing enabled statusDefault: errors = {}Flag equivalent: noneENV equivalent: noneEquivalent configs:type check rule overridesand type evaluation settingsin Pyright,enable_error_code anddisable_error_codein mypyNotes: setting &lt;error-code&gt; = true is the same as having no error code configuration present, which means the error will be shown. Setting &lt;error-code&gt; = false will disable the error for type checking. replace_imports_with_any: ModuleGlobs of modules from which import errors should be ignored, and the module should be replaced with typing.Any. For example, withfrom x.y import z in a file, adding x.*, *.y, or x.y to this config will silence those import errors and replace the module with typing.Any. If the module can be found, its type information will still be replaced with typing.Any. Type: list of regexDefault: []Flag equivalent: noneENV equivalent: noneEquivalent configs: ignore_missing_imports in mypyNotes: errors = {import-error = false} (TOML inline table for errors) has similar behavior in Pyrefly, but ignoresall import errors instead of import errors from specific modules, and won't replace findable modules with typing.Any. ignore_errors_in_generated_code: Whether to ignore type errors in generated code. If enabled, generated files will be treated as if they are included in project_excludes. Generated code are determined by checking if the file contents contain the substring {'@' + 'generated'}. Type: boolDefault: falseFlag equivalent: --ignore-errors-in-generated-codeENV equivalent: IGNORE_ERRORS_IN_GENERATED_CODE  ","version":"Next","tagName":"h2"},{"title":"Environment Autoconfiguration‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#environment-autoconfiguration","content":" If any of python_platform, python_version, or site_package_path are empty, we attempt to query an interpreter for the missing values. By default we query python3 if it's available on the path, but the interpreter can be overridden with the python_interpreter config option and flag. If the interpreter does not exist, we fall back to Pyrefly's defaults for all unspecified values.  The values queried from the interpreter are:  python_platform: sys.platformpython_version: sys.version_info[:3]site_package_path: site.getsitepackages()  ","version":"Next","tagName":"h2"},{"title":"Module globbing‚Äã","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#module-globbing","content":" In some functionality, we've added globbing for module paths. This is different from both path globs and regex, in the sense that we're performing a match on a Python dotted import, such as this.is.any.module. The only wildcard we recognize is *, which represents zero or more segments of a module path, unless it starts a glob, in which case it must match one or more segments. The wildcard must be surrounded by ., unless it is at the start or end of a module glob.  Examples:  this.is.a.module would be equivalent to a regex like ^this\\.is\\.a\\.module. It will only match imports that look likethis.is.a.module.this.is.*.module would become ^this\\.is(\\..+)*\\.module$. It would match: this.is.modulethis.is.a.modulethis.is.a.really.long.path.to.a.module *.my.module would be equivalent to a regex like ^.+\\.my\\.module$. It would match: this.is.my.moduleheres.my.module It will not match: my.module this.is.* would be equivalent to a regex like ^this\\.is(\\..+)*. It would match: this.is.my.modulethis.is ","version":"Next","tagName":"h2"},{"title":"Import Resolution","type":0,"sectionRef":"#","url":"/en/docs/import-resolution/","content":"","keywords":"","version":"Next"},{"title":"Relative Imports‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#relative-imports","content":" If the import is relative (starting with one or more dots), the import is resolved relative to the path of the file importing it. A single dot at the beginning of the import (e.g. .file.to.import) represents the current directory, and more dots (e.g. ..other.file) will continue to walk upward.  ","version":"Next","tagName":"h2"},{"title":"Absolute Imports‚Äã","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#absolute-imports","content":" For absolute imports, Pyrefly uses the following import strategy:  Try to import from each entry in import_roots in the order they appear using the module finding strategy. a. NOTE: we append the config file's directory to search_roots automatically when using a config file as a sensible last-resort for attempting an import.Try to import from typeshed.Try to import from each entry in site_package_path in the order it appears using the module finding strategy.Return an import error.  Stub Files vs Source Files  Astub fileis any file that ends with a .pyi file suffix. They have many uses, including adding typing to non-Python extension code, distributing typing information separate from implementation, or overriding an implementation with more accurate typing information.  Pyrefly loads typing information from imports by first searching for a relevant.pyi file, then falling back to a .py file, for each attempt at an import above. ","version":"Next","tagName":"h2"},{"title":"Give Pyrefly a try with some working examples","type":0,"sectionRef":"#","url":"/en/docs/learn-python-typing/","content":"","keywords":"","version":"Next"},{"title":"The Basics‚Äã","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#the-basics","content":" Python's built-in types can be used to write many simple type hints.    ","version":"Next","tagName":"h2"},{"title":"Functions‚Äã","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#functions","content":" Defining the parameter and return types for a function doesn't just help prevent bugs, but it makes it easier to navigate in other files. You don't always need to define a return type - we'll do our best to infer it for you! We can't always get it right and an explicit return type will help your IDE navigate faster and more accurately.    ","version":"Next","tagName":"h2"},{"title":"Generics‚Äã","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#generics","content":" Generics allow you to define reusable functions and classes that work with multiple types. This feature enables you to write more flexible and adaptable code.    ","version":"Next","tagName":"h2"},{"title":"Protocols‚Äã","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#protocols","content":" Protocols enable structural typing, which allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.    ","version":"Next","tagName":"h2"},{"title":"Dataclasses‚Äã","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#dataclasses","content":" Dataclasses allow you to create type-safe data structures while minimizing boilerplate.    ","version":"Next","tagName":"h2"},{"title":"TypedDict‚Äã","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#typeddict","content":" Typed dictionaries enable you to define dictionaries with specific key-value types. This feature lets you bring type safety to ad-hoc dictionary structures without major refactoring.    ","version":"Next","tagName":"h2"},{"title":"Overloads‚Äã","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#overloads","content":" Overloads allow you to define multiple function signatures for a single function. Like generics, this feature helps you write more flexible and adaptable code.   ","version":"Next","tagName":"h2"},{"title":"Pyrefly Frequently Asked Questions","type":0,"sectionRef":"#","url":"/en/docs/pyrefly-faq/","content":"","keywords":"","version":"Next"},{"title":"What is Pyrefly?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#what-is-pyrefly","content":" Pyrefly is a type checker for Python powering a fast and flexible IDE experience. It's a work in progress, but showing promising results for checking large code bases, better type inference and giving instant responses in IDE.  ","version":"Next","tagName":"h3"},{"title":"How do I pronounce Pyrefly?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-pronounce-pyrefly","content":" It's pronounced PIE-ur-fly, rhyming with &quot;firefly.&quot;  ","version":"Next","tagName":"h3"},{"title":"What is the relationship to Pyre?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#what-is-the-relationship-to-pyre","content":" Pyrefly is a ground-up rebuild that doesn‚Äôt share any core type checking code with Pyre. Not only is Pyrefly written in a new language (Rust instead of OCaml), but our design deviates in a major way from Pyre. Rust enables us to deliver substantial performance improvements and support multiple operating systems (including Windows). Beyond the core type checker itself, there are helper tooling and many lessons learned that we will take from Pyre and the community of Python type checking maintainers who have done tremendous work to get the state of type checking to where it is today.  ","version":"Next","tagName":"h3"},{"title":"Yet another Type Checker! Why not improve the ones adopted by the community already?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#yet-another-type-checker-why-not-improve-the-ones-adopted-by-the-community-already","content":" We are standing on the shoulders of giants. The contributions to Python typing by Mypy, Pyright, Pytype, Pyre and others have been invaluable. We borrowed concepts and learned from them as we rolled our own. Open source conformance matters to us a lot. While we might make some opinionated decisions, we will adhere to the PEP process. Pyre was the only type checker that could scale for Meta‚Äôs needs and was starting to show its age, so we started with a ground-up rewrite aimed at usability and performance.  We built our own engine for incremental computation and designed our type checking algorithm based on years of experience in gradual type theory and Rust expertise. By open-sourcing this technology we hope it can serve projects of any size well.  ","version":"Next","tagName":"h3"},{"title":"Why Rust?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#why-rust","content":" We would have preferred to write Pyrefly in Python, but didn't think we could hit our ambitious performance goals using Python today (hopefully future work around free-threaded Python and JIT changes that). After ruling out Python, we wanted something that was safe, cross-platform, compiled to WASM (for a Playground experience). Rust and Go are probably the best choices for those goals, and our team at Meta had more experience with Rust.  ","version":"Next","tagName":"h3"},{"title":"Do you plan to build an LSP?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#do-you-plan-to-build-an-lsp","content":" Yes. See our roadmap for details.  ","version":"Next","tagName":"h3"},{"title":"Where do I report bugs?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#where-do-i-report-bugs","content":" Please open an issue on our GitHub page. You can leave feature requests there as well :) Our current goal is to get through our first major milestone, and after that we can look at bugs and features beyond the current roadmap.  ","version":"Next","tagName":"h3"},{"title":"Can I contribute to Pyrefly?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#can-i-contribute-to-pyrefly","content":" Please see the: contributing guidelines.  ","version":"Next","tagName":"h3"},{"title":"How do I know this project won't go unmaintained after a year?‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#how-do-i-know-this-project-wont-go-unmaintained-after-a-year","content":" Great question. We have made a substantial investment in Pyrefly, use it internally and aligned open source maintainability as a key principle for starting this project in the first place. We‚Äôre in it for the long haul. Using it is the best way to see increased investment from our leadership.  ","version":"Next","tagName":"h3"},{"title":"This is cool, I want to learn more about the technical details.‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#this-is-cool-i-want-to-learn-more-about-the-technical-details","content":" See our README.md for the high level design. We plan to add more detailed documentation along with announcements on https://engineering.fb.com  ","version":"Next","tagName":"h3"},{"title":"I don't like Python's Type System. Stop wasting your time.‚Äã","type":1,"pageTitle":"Pyrefly Frequently Asked Questions","url":"/en/docs/pyrefly-faq/#i-dont-like-pythons-type-system-stop-wasting-your-time","content":" Tell us more - seriously we want to hear your objections to typing! We hope that better tooling, improvements to the type system and well typed libraries will help provide make development easier. If all else fails our fast code navigation and inference algorithm might spark joy in your IDE, so give us a chance.  Curious about something else or just want to chat about bolting types onto Python, join us on Discord. ","version":"Next","tagName":"h3"},{"title":"Error Kinds","type":0,"sectionRef":"#","url":"/en/docs/error-kinds/","content":"","keywords":"","version":"Next"},{"title":"annotation-mismatch‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#annotation-mismatch","content":" This error indicates a mismatch between multiple annotations for a single variable. This is relatively uncommon, but it can happen in if-statements:  if some_cond: x: int = 1 else: x: str = &quot;two&quot; # Inconsistent type annotations for x: str, int [annotation-mismatch]   It can be helpful to annotate the variable before branch, especially if there is a useful default value for it. For example:  x: str = &quot;default&quot; if some_cond: x = &quot;actual value&quot;   ","version":"Next","tagName":"h2"},{"title":"assert-type‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#assert-type","content":" An assert-type error is raised when a typing.assert_type() call fails.  This error kind should never be suppressed, since that rather defeats the point of of typing.assert_type().  ","version":"Next","tagName":"h2"},{"title":"async-error‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#async-error","content":" async-error is reported when attempting to await on something that is not awaitable. This may indicate that a function should have been marked async but wasn't.  def some_func() -&gt; None: ... await some_func() # Expression is not awaitable [async-error]   This will also arise if the context manager used in an async with statement has __aenter__ and __aexit__ methods that are not marked async.  The fix is to use an async function in the await. This may mean making the function async or finding an existing async function to use instead.  ","version":"Next","tagName":"h2"},{"title":"bad-argument-count‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-argument-count","content":" This error arises when a function is called with the wrong number of arguments.  def takes_three(one: int, two: int, three: int) -&gt; complex: ... take_three(3, 2) # Expected 1 more positional argument [bad-argument-count]   Note that missing-argument will be raised if pyrefly can identify that specific arguments are missing. As such, this error is more likely to appear when too many args are supplied, rather than too few.  This example shows both kinds of errors:  from typing import Callable def apply(f: Callable[[int, int], int]) -&gt; int: return f(1) # Expected 1 more positional argument [bad-argument-count] apply() # Missing argument `f` in function `apply` [missing-argument]   ","version":"Next","tagName":"h2"},{"title":"bad-argument-type‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-argument-type","content":" This error indicates that the function was called with an argument of the wrong type.  def example(x: int) -&gt; None: ... example(&quot;one&quot;) # Argument `Literal['two']` is not assignable to parameter `x` with type `int` in function `example` [bad-argument-type]   This can also happen with *args and **kwargs:  def bad_args(*args: int) -&gt; None: ... bad_args(1, &quot;two&quot;) # Argument `Literal['two']` is not assignable to parameter with type `int` in function `bad_args` [bad-argument-type]   def bad_kwargs(**kwargs: int) -&gt; None: ... bad_args(x=1, y=&quot;two&quot;) # Keyword argument `y` with type `Literal['two']` is not assignable to kwargs type `int` in function `bad_kwargs` [bad-argument-type]   ","version":"Next","tagName":"h2"},{"title":"bad-assignment‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-assignment","content":" The most common cause of this error is attempting to assign a value that conflicts with the variable's type annotation.  x: str = 1 # `Literal[1]` is not assignable to `str` [bad-assignment]   However, it can occur in several other situations.  Here, x is marked as Final, so assigning a new value to it is an error.  from typing import Final x: Final = 1 x = 2 # `x` is marked final [bad-assignment]   In another case, attempting to annotate an assignment to an instance attribute raises this error.  class A: x: int a = A() a.x: int = 2 # Type cannot be declared in assignment to non-self attribute `a.x` [bad-assignment]   ","version":"Next","tagName":"h2"},{"title":"bad-class-definition‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-class-definition","content":" This error indicates that there is something wrong with the class definition. It tends to be a bit rarer, since most issues would be tagged with other error kinds, such asannotation-mismatch or one of the function errors. inheritance has its own complexities, so it has its own error kind called invalid-inheritance.  One place you may see it is dynamic class generation:  from enum import Enum Ex = Enum(&quot;Ex&quot;, [(&quot;Red&quot;, 1), (&quot;Blue&quot;, 2), (&quot;Red&quot;, 3)]) # Duplicate field `Red` [bad-class-definition]   However, it is best practice to use the class syntax if possible, which doesn't treat duplicate names as an error.  ","version":"Next","tagName":"h2"},{"title":"bad-function-definition‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-function-definition","content":" Like bad-class-definition, this error kind is uncommon because other error kinds are used for more specific issues. For example, argument order is enforced by the parser, so def f(x: int = 1, y: str) is a parse-error.  ","version":"Next","tagName":"h2"},{"title":"bad-keyword-argument‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-keyword-argument","content":" Attempting to call a function with an incorrect keyword argument. e.g. f(x=1, x=2), or perhaps f(y=1) (where f has no parameter y).  ","version":"Next","tagName":"h2"},{"title":"bad-override‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-override","content":" A subclass field or method incorrectly overrides a field/method of a parent class.  ","version":"Next","tagName":"h2"},{"title":"bad-return‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-return","content":" Attempting to return a value that does not match the function's return type. Can also arise when returning values from generators.  ","version":"Next","tagName":"h2"},{"title":"bad-specialization‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-specialization","content":" Attempting to specialize a generic class with incorrect type arguments. e.g.type[int, str] is an error because type accepts only 1 type arg.  ","version":"Next","tagName":"h2"},{"title":"bad-unpacking‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#bad-unpacking","content":" An error caused by unpacking. e.g. attempting to unpack an iterable into the wrong number of variables.  ","version":"Next","tagName":"h2"},{"title":"match-error‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#match-error","content":" An error caused by a bad match statement. e.g. Writing a Foo(x, y, z) pattern when Foo only matches on (x, y).  ","version":"Next","tagName":"h2"},{"title":"missing-attribute‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#missing-attribute","content":" Attempting to access an attribute that does not exist.  ","version":"Next","tagName":"h2"},{"title":"import-error‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#import-error","content":" An error related to the import machinery. e.g. failed to import a module.  ","version":"Next","tagName":"h2"},{"title":"index-error‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#index-error","content":" Attempting to access a container with an incorrect index. This only occurs when pyre can statically verify that the index is incorrect.  ","version":"Next","tagName":"h2"},{"title":"internal-error‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#internal-error","content":" Internal Pyre error.  ","version":"Next","tagName":"h2"},{"title":"invalid-annotation‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-annotation","content":" Attempting to write an annotation that is invalid for some reason.  ","version":"Next","tagName":"h2"},{"title":"invalid-argument‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-argument","content":" Passing an argument that is invalid for reasons besides type.  ","version":"Next","tagName":"h2"},{"title":"invalid-inheritance‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-inheritance","content":" An error caused by incorrect inheritance in a class or type definition. e.g. a metaclass that is not a subclass of type.  ","version":"Next","tagName":"h2"},{"title":"invalid-literal‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-literal","content":" Attempting to use a value that is not a valid kind of Literal.  ","version":"Next","tagName":"h2"},{"title":"invalid-overload‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-overload","content":" An error caused by incorrect usage of the @overload decorator. e.g. not defining multiple variants for an overloaded function.  ","version":"Next","tagName":"h2"},{"title":"invalid-param-spec‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-param-spec","content":" An error related to ParamSpec definition or usage.  ","version":"Next","tagName":"h2"},{"title":"invalid-super-call‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-super-call","content":" Attempting to call super() in a way that is not allowed. e.g. callingsuper(Y, x) on an object x that does not match the class Y.  ","version":"Next","tagName":"h2"},{"title":"invalid-type-var‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var","content":" An error caused by incorrect usage or definition of a TypeVar.  ","version":"Next","tagName":"h2"},{"title":"invalid-type-var-tuple‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-type-var-tuple","content":" An error caused by incorrect usage or definition of a TypeVarTuple.  ","version":"Next","tagName":"h2"},{"title":"invalid-yield‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#invalid-yield","content":" Attempting to use yield in a way that is not allowed. e.g. yield from with something that's not an iterable.  ","version":"Next","tagName":"h2"},{"title":"missing-argument‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#missing-argument","content":" An error caused by calling a function without all the required arguments. Should be used when we can name the specific arguments that are missing.  ","version":"Next","tagName":"h2"},{"title":"missing-module-attribute‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#missing-module-attribute","content":" Accessing an attribute that does not exist on a module.  ","version":"Next","tagName":"h2"},{"title":"no-access‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#no-access","content":" The attribute exists but does not support this access pattern.  ","version":"Next","tagName":"h2"},{"title":"no-matching-overload‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#no-matching-overload","content":" Attempting to call an overloaded function, but none of the signatures match.  ","version":"Next","tagName":"h2"},{"title":"not-a-type‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#not-a-type","content":" Attempting to use something that isn't a type where a type is expected. This is a very general error and should be used sparingly.  ","version":"Next","tagName":"h2"},{"title":"not-callable‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#not-callable","content":" Attempting to call a value that is not a callable.  ","version":"Next","tagName":"h2"},{"title":"not-iterable‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#not-iterable","content":" Attempting to use a non-iterable value as an iterable.  ","version":"Next","tagName":"h2"},{"title":"parse-error‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#parse-error","content":" An error related to parsing or syntax.  ","version":"Next","tagName":"h2"},{"title":"read-only‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#read-only","content":" The attribute exists but cannot be modified.  ","version":"Next","tagName":"h2"},{"title":"reveal-type‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#reveal-type","content":" Raised by a call to reveal_type().  ","version":"Next","tagName":"h2"},{"title":"type-alias-error‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#type-alias-error","content":" An error related to type alias usage or definition.  ","version":"Next","tagName":"h2"},{"title":"typed-dict-key-error‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#typed-dict-key-error","content":" An error related to TypedDict keys. e.g. attempting to access a TypedDict with a key that does not exist.  ","version":"Next","tagName":"h2"},{"title":"unexpected-keyword‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unexpected-keyword","content":" An error caused by a keyword argument used in the wrong place.  ","version":"Next","tagName":"h2"},{"title":"unknown-name‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unknown-name","content":" Attempting to use a name that is not defined.  ","version":"Next","tagName":"h2"},{"title":"unsupported-operand‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unsupported-operand","content":" Attempting to apply an operator to arguments that do not support it.  ","version":"Next","tagName":"h2"},{"title":"unsupported‚Äã","type":1,"pageTitle":"Error Kinds","url":"/en/docs/error-kinds/#unsupported","content":" Attempting to use a feature that is not yet supported. ","version":"Next","tagName":"h2"}]