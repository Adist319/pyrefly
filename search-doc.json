[{"title":"Import Resolution","type":0,"sectionRef":"#","url":"/en/docs/import-resolution/","content":"","keywords":"","version":"Next"},{"title":"Relative Imports​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#relative-imports","content":" If the import is relative (starting with one or more dots), the import is resolved relative to the path of the file importing it. A single dot at the beginning of the import (e.g. .file.to.import) represents the current directory, and more dots (e.g. ..other.file) will continue to walk upward.  ","version":"Next","tagName":"h2"},{"title":"Absolute Imports​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#absolute-imports","content":" For absolute imports, Pyrefly uses the following import strategy:  Try to import from each entry in import_roots in the order they appear using the module finding strategy. a. NOTE: we append the config file's directory to search_roots automatically when using a config file as a sensible last-resort for attempting an import.Try to import from typeshed.Try to import from each entry in site_package_path in the order it appears using the module finding strategy.Return an import error.  Stub Files vs Source Files  Astub fileis any file that ends with a .pyi file suffix. They have many uses, including adding typing to non-Python extension code, distributing typing information separate from implementation, or overriding an implementation with more accurate typing information.  Pyrefly loads typing information from imports by first searching for a relevant.pyi file, then falling back to a .py file, for each attempt at an import above. ","version":"Next","tagName":"h2"},{"title":"Pyrefly Configuration","type":0,"sectionRef":"#","url":"/en/docs/configuration/","content":"","keywords":"","version":"Next"},{"title":"Precedence in Options​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#precedence-in-options","content":" The following is the order in which configuration options are selected:  CLI flagEnvironment variable override -- This is the same as PYRE_&lt;CLI flag name&gt;Configuration optionHard-coded default  Configuration Options  project_includes: the glob patterns used to describe which files to type check, typically understood as user-space files. This takes highest precedence in import resolution. Type: list of Unix Glob patternsDefault: [&quot;**/*.py&quot;]Flag equivalent: FILES... argumentEquivalent configs: include in Pyright, files/modules/packages in MyPyNotes: when overridden by passing in FILES..., we do not consult the relevant config file for what to use for project_excludes. Ifproject_excludes should not use the default, override it with the flag as well. project_excludes: the glob patterns used to describe which files to avoid type checking, usually as a more fine-grained way of controlling the files you get type errors on. Type: list of Unix Glob patternsDefault: [&quot;**/__pycache__/**&quot;, &quot;**/.*&quot;]Flag equivalent: --project-excludesEquivalent configs: exclude in Pyright and MyPyNotes: we match on these patterns, unlike project_includes, where we enumerate all (Python) files under the directory. Becaues of this,project_excludes does not do directory matching unless a / is added at the end of your glob pattern. **/__pycache__/ will only match files under a directory named __pycache__/, but not a file named __pycache__. Likewise, **/__pycache__ will only match files named __pycache__, but not files under a directory named __pycache__/. search_path: a file path describing a root from which imports should be found and imported from (including modules in project_includes). This takes the highest precedence in import order, before typeshed andsite_package_path. When a project_includes type checked file is imported by another type checked file, we check all search roots to determine how to import it. Type: list of directoriesDefault: [&quot;.&quot;]Flag equivalent: --search-pathENV equivalent: PYRE_SEARCH_PATHEquivalent configs: extraPaths in Pyright, mypy_path in MyPyNotes: we automatically append &quot;.&quot; (the directory containing the configuration file) to the search_roots when type checking as a sensible default and last attempt at an import. site_package_path: a file path describing a root from which imports should be found and imported from. This takes the lowest priority in import resolution, after project_includes, typeshed, and search_roots. Type: list of directoriesDefault: [&quot;.&quot;]Flag equivalent: --site-package-pathENV equivalent: PYRE_SITE_PACKAGE_PATHEquivalent configs: none python_platform: the value used with conditions based on type checking againstsys.platformvalues. Type: stringDefault: &quot;linux&quot;Flag equivalent: --python-platformENV equivalent: PYRE_PYTHON_PLATFORMEquivalent configs: pythonPlatform in Pyright, platform in MyPy python_version: the value used with conditions based on type checking againstsys.versionvalues. The format should be &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]], where minor and micro can be omitted to take the default positional value. Type: stringDefault: 3.13.0Flag equivalent: --python-versionENV equivalent: PYRE_PYTHON_VERSIONEquivalent configs: pythonVersion in Pyright, python_version in MyPy errors: configure (enable and disable) the errors Pyrefly shows Type: Table of error code name to boolean representing enabled statusDefault: errors = {}Flag equivalent: noneENV equivalent: noneEquivalent configs:type check rule overridesand type evaluation settingsin Pyright,enable_error_code anddisable_error_codein MyPyNotes: setting &lt;error-code&gt; = true is the same as having no error code configuration present, which means the error will be shown. Setting &lt;error-code&gt; = false will disable the error for type checking. ","version":"Next","tagName":"h2"},{"title":"Give Pyrefly a try with some working examples","type":0,"sectionRef":"#","url":"/en/docs/learn-python-typing/","content":"","keywords":"","version":"Next"},{"title":"The Basics​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#the-basics","content":" Python's built-in types can be used to write many simple type hints.    ","version":"Next","tagName":"h2"},{"title":"Functions​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#functions","content":" Defining the parameter and return types for a function doesn't just help prevent bugs, but it makes it easier to navigate in other files. You don't always need to define a return type - we'll do our best to infer it for you! We can't always get it right and an explicit return type will help your IDE navigate faster and more accurately.    ","version":"Next","tagName":"h2"},{"title":"Generics​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#generics","content":" Generics allow you to define reusable functions and classes that work with multiple types. This feature enables you to write more flexible and adaptable code.    ","version":"Next","tagName":"h2"},{"title":"Protocols​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#protocols","content":" Protocols enable structural typing, which allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.    ","version":"Next","tagName":"h2"},{"title":"Dataclasses​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#dataclasses","content":" Dataclasses allow you to create type-safe data structures while minimizing boilerplate.    ","version":"Next","tagName":"h2"},{"title":"TypedDict​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#typeddict","content":" Typed dictionaries enable you to define dictionaries with specific key-value types. This feature lets you bring type safety to ad-hoc dictionary structures without major refactoring.    ","version":"Next","tagName":"h2"},{"title":"Overloads​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#overloads","content":" Overloads allow you to define multiple function signatures for a single function. Like generics, this feature helps you write more flexible and adaptable code.   ","version":"Next","tagName":"h2"}]