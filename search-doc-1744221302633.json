[{"title":"Import Resolution","type":0,"sectionRef":"#","url":"/en/docs/import-resolution/","content":"","keywords":"","version":"Next"},{"title":"Relative Imports​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#relative-imports","content":" If the import is relative (starting with one or more dots), the import is resolved relative to the path of the file importing it. A single dot at the beginning of the import (e.g. .file.to.import) represents the current directory, and more dots (e.g. ..other.file) will continue to walk upward.  ","version":"Next","tagName":"h2"},{"title":"Absolute Imports​","type":1,"pageTitle":"Import Resolution","url":"/en/docs/import-resolution/#absolute-imports","content":" For absolute imports, Pyrefly uses the following import strategy:  Try to import from each entry in import_roots in the order they appear using the module finding strategy. a. NOTE: we append the config file's directory to search_roots automatically when using a config file as a sensible last-resort for attempting an import.Try to import from typeshed.Try to import from each entry in site_package_path in the order it appears using the module finding strategy.Return an import error.  Stub Files vs Source Files  Astub fileis any file that ends with a .pyi file suffix. They have many uses, including adding typing to non-Python extension code, distributing typing information separate from implementation, or overriding an implementation with more accurate typing information.  Pyrefly loads typing information from imports by first searching for a relevant.pyi file, then falling back to a .py file, for each attempt at an import above. ","version":"Next","tagName":"h2"},{"title":"Give Pyrefly a try with some working examples","type":0,"sectionRef":"#","url":"/en/docs/learn-python-typing/","content":"","keywords":"","version":"Next"},{"title":"The Basics​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#the-basics","content":" Python's built-in types can be used to write many simple type hints.    ","version":"Next","tagName":"h2"},{"title":"Functions​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#functions","content":" Defining the parameter and return types for a function doesn't just help prevent bugs, but it makes it easier to navigate in other files. You don't always need to define a return type - we'll do our best to infer it for you! We can't always get it right and an explicit return type will help your IDE navigate faster and more accurately.    ","version":"Next","tagName":"h2"},{"title":"Generics​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#generics","content":" Generics allow you to define reusable functions and classes that work with multiple types. This feature enables you to write more flexible and adaptable code.    ","version":"Next","tagName":"h2"},{"title":"Protocols​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#protocols","content":" Protocols enable structural typing, which allows you to define interfaces without explicit inheritance. This feature helps you write more modular and composable code.    ","version":"Next","tagName":"h2"},{"title":"Dataclasses​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#dataclasses","content":" Dataclasses allow you to create type-safe data structures while minimizing boilerplate.    ","version":"Next","tagName":"h2"},{"title":"TypedDict​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#typeddict","content":" Typed dictionaries enable you to define dictionaries with specific key-value types. This feature lets you bring type safety to ad-hoc dictionary structures without major refactoring.    ","version":"Next","tagName":"h2"},{"title":"Overloads​","type":1,"pageTitle":"Give Pyrefly a try with some working examples","url":"/en/docs/learn-python-typing/#overloads","content":" Overloads allow you to define multiple function signatures for a single function. Like generics, this feature helps you write more flexible and adaptable code.   ","version":"Next","tagName":"h2"},{"title":"Pyrefly Configuration","type":0,"sectionRef":"#","url":"/en/docs/configuration/","content":"","keywords":"","version":"Next"},{"title":"Precedence in Options​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#precedence-in-options","content":" The following is the order in which configuration options are selected:  CLI flagEnvironment variable override -- This is the same as PYRE_&lt;CLI flag name&gt;Configuration optionHard-coded default  ","version":"Next","tagName":"h2"},{"title":"Configuration Finding​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-finding","content":" In both project checking mode (with no explicit configuration supplied) and single-file checking mode, we perform an upward file search to find a configuration file. We check each directory from the start location to the filesystem root, looking first for pyrefly.toml then pyproject.toml, in the same directory before looking at its parent.  For project checking mode, the start location is the CWD. We do not perform any searching if the --config/-c flag is used. For single-file checking mode, the start location is the directory containing the file to be type checked. No config flag can be passed into Pyrefly in single file checking mode.  If a pyrefly.toml is found, it is parsed and used for type checking, and will return an error to the user on invalid types, syntax, or values.  If a pyproject.toml is found, Pyrefly will stop searching, even if no [tool.pyrefly]section is found. The same errors will be returned as when loading a pyrefly.toml if the config is invalid.  ","version":"Next","tagName":"h2"},{"title":"Configuration Options​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#configuration-options","content":" project_includes: the glob patterns used to describe which files to type check, typically understood as user-space files. This takes highest precedence in import resolution. Type: list of Unix Glob patternsDefault: [&quot;**/*.py&quot;]Flag equivalent: FILES... argumentEquivalent configs: include in Pyright, files/modules/packages in mypyNotes: When overridden by passing in FILES..., we do not consult the relevant config file for what to use for project_excludes. Ifproject_excludes should not use the default value, override it with the flag as well.When a project_includes pattern does not match any files, we will return an error. project_excludes: the glob patterns used to describe which files to avoid type checking, usually as a more fine-grained way of controlling the files you get type errors on. Type: list of Unix Glob patternsDefault: [&quot;**/__pycache__/**&quot;, &quot;**/.*&quot;]Flag equivalent: --project-excludesEquivalent configs: exclude in Pyright and mypyNotes: We match on these patterns, unlike project_includes, where we enumerate all (Python) files under the directory. Because of this,project_excludes does not do directory matching unless a / is added at the end of your glob pattern. **/__pycache__/ will only match files under a directory named __pycache__/, but not a file named __pycache__. Likewise, **/__pycache__ will only match files named __pycache__, but not files under a directory named __pycache__/.It is an error if no files are returned from any project_includes because they are filtered out by project_excludes entries.When passing in FILES..., we also do not consult the config file for what to use for project_excludes. If project_excludes should not use the default value, override it with a flag as well. search_path: a file path describing a root from which imports should be found and imported from (including modules in project_includes). This takes the highest precedence in import order, before typeshed andsite_package_path. When a project_includes type checked file is imported by another type checked file, we check all search roots to determine how to import it. Type: list of directoriesDefault: [&quot;.&quot;]Flag equivalent: --search-pathENV equivalent: PYRE_SEARCH_PATHEquivalent configs: extraPaths in Pyright, mypy_path in mypyNotes: we automatically append &quot;.&quot; (the directory containing the configuration file) to the search_roots when type checking as a sensible default and last attempt at an import. site_package_path: a file path describing a root from which imports should be found and imported from. This takes the lowest priority in import resolution, after project_includes, typeshed, and search_roots. Type: list of directoriesDefault: result from Environment Autoconfiguration or []Flag equivalent: --site-package-pathENV equivalent: PYRE_SITE_PACKAGE_PATHEquivalent configs: none python_platform: the value used with conditions based on type checking againstsys.platformvalues. Type: stringDefault: result from Environment Autoconfiguration or &quot;linux&quot;Flag equivalent: --python-platformENV equivalent: PYRE_PYTHON_PLATFORMEquivalent configs: pythonPlatform in Pyright, platform in mypy python_version: the value used with conditions based on type checking againstsys.versionvalues. The format should be &lt;major&gt;[.&lt;minor&gt;[.&lt;micro&gt;]], where minor and micro can be omitted to take the default positional value. Type: stringDefault: result from Environment Autoconfiguration or 3.13.0Flag equivalent: --python-versionENV equivalent: PYRE_PYTHON_VERSIONEquivalent configs: pythonVersion in Pyright, python_version in mypy python_interpreter: the Python interpreter to query when attempting to autoconfigure Python environment values (site_package_path, python_platform, python_version). See the Environment Autoconfiguration section for more information. Type: string of executable or path to executableDefault: python3Flag equivalent: --python-interpreterENV equivalent: PYRE_PYTHON_INTERPRETEREquivalent configs: python_executable in mypyNotes: This executes the value present in the python_interpreter field without any checks. It could be a security risk if your python_interpreter executes an arbitrary executable.If you are working on a project shared between multiple people, it is likely best not to use this option, since there might be different Python interpreter versions used on different systems. Instead, we recommend explicitly setting python_version, python_platform, and site_package_path, or using alternative methods of environment autoconfiguration (coming soon). errors: configure (enable and disable) the errors Pyrefly shows Type: Table of error code name to boolean representing enabled statusDefault: errors = {}Flag equivalent: noneENV equivalent: noneEquivalent configs:type check rule overridesand type evaluation settingsin Pyright,enable_error_code anddisable_error_codein mypyNotes: setting &lt;error-code&gt; = true is the same as having no error code configuration present, which means the error will be shown. Setting &lt;error-code&gt; = false will disable the error for type checking. replace_imports_with_any: names of modules from which import errors should be ignored, and the module should be replaced with typing.Any. For example, withfrom x.y import z in a file, adding x, x.* or x.y to this config will silence those import errors and replace the module with typing.Any. If the module can be found, its type information will still be replaced with typing.Any. Type: list of regexDefault: []Flag equivalent: noneENV equivalent: noneEquivalent configs: ignore_missing_imports in mypyNotes: reportMissingImports = false has similar behavior in Pyright, but ignores all import errors instead of import errors from specific modules. ignore_errors_in_generated_code: Whether to ignore type errors in generated code. If enabled, generated files will be treated as if they are included in project_excludes. Generated code are determined by checking if the file contents contain the substring {'@' + 'generated'}. Type: boolDefault: falseFlag equivalent: --ignore-errors-in-generated-codeENV equivalent: IGNORE_ERRORS_IN_GENERATED_CODE  ","version":"Next","tagName":"h2"},{"title":"Environment Autoconfiguration​","type":1,"pageTitle":"Pyrefly Configuration","url":"/en/docs/configuration/#environment-autoconfiguration","content":" If any of python_platform, python_version, or site_package_path are empty, we attempt to query an interpreter for the missing values. By default we query python3 if it's available on the path, but the interpreter can be overridden with the python_interpreter config option and flag. If the interpreter does not exist, we fall back to Pyrefly's defaults for all unspecified values.  The values queried from the interpreter are:  python_platform: sys.platformpython_version: sys.version_info[:3]site_package_path: site.getsitepackages() ","version":"Next","tagName":"h2"}]