"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5839],{65839:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"import-resolution","title":"Import Resolution","description":"How Pyrefly finds and resolves imports","source":"@site/docs/import-resolution.mdx","sourceDirName":".","slug":"/import-resolution","permalink":"/en/docs/import-resolution","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/pyrefly/edit/main/website/docs/import-resolution.mdx","tags":[],"version":"current","frontMatter":{"title":"Import Resolution","slug":"/import-resolution","description":"How Pyrefly finds and resolves imports"},"sidebar":"docsSidebar","previous":{"title":"Error Kinds","permalink":"/en/docs/error-kinds"}}');var s=t(74848),r=t(28453);const o={title:"Import Resolution",slug:"/import-resolution",description:"How Pyrefly finds and resolves imports"},a="Import Resolution",l={},c=[{value:"Relative Imports",id:"relative-imports",level:2},{value:"Absolute Imports",id:"absolute-imports",level:2},{value:"Site Package Path Typing Rules",id:"site-package-path-typing-rules",level:3},{value:"Stub Files vs Source Files",id:"stub-files-vs-source-files",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"import-resolution",children:"Import Resolution"})}),"\n",(0,s.jsx)(n.p,{children:"This doc describes how imports in a given file are found and their bindings are\nresolved, including files that are being type checked."}),"\n",(0,s.jsxs)(n.p,{children:["NOTE: see the ",(0,s.jsx)(n.a,{href:"/en/docs/configuration",children:"Configuration documentation"})," for more info on\nthe config items referenced below."]}),"\n",(0,s.jsx)(n.h2,{id:"relative-imports",children:"Relative Imports"}),"\n",(0,s.jsxs)(n.p,{children:["If the import is relative (starting with one or more dots), the import is\nresolved relative to the path of the file importing it. A single dot at the\nbeginning of the import (e.g. ",(0,s.jsx)(n.code,{children:".file.to.import"}),") represents the current\ndirectory, and more dots (e.g. ",(0,s.jsx)(n.code,{children:"..other.file"}),") will continue to walk upward."]}),"\n",(0,s.jsx)(n.h2,{id:"absolute-imports",children:"Absolute Imports"}),"\n",(0,s.jsx)(n.p,{children:"For absolute imports, Pyrefly uses the following import strategy:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Try to import from each entry in ",(0,s.jsx)(n.a,{href:"/en/docs/configuration#search_path",children:(0,s.jsx)(n.code,{children:"search_path"})})," in the order they appear\nusing the module finding strategy. a. NOTE: we append the config file's\ndirectory to ",(0,s.jsx)(n.code,{children:"search_path"})," automatically when using a config file as a\nsensible last-resort for attempting an import."]}),"\n",(0,s.jsxs)(n.li,{children:["Try to import from ",(0,s.jsx)(n.code,{children:"typeshed"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Try to find a stub package corresponding to the import we're trying to resolve in\n",(0,s.jsx)(n.a,{href:"/en/docs/configuration#site_package_path",children:(0,s.jsx)(n.code,{children:"site_package_path"})}),".\nEntries earlier in the ",(0,s.jsx)(n.code,{children:"site_package_path"})," list will be selected before those appearing later in the list.\nSee ",(0,s.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#stub-only-packages",children:"the typing spec"})," for\nmore info on stub packages.","\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["If we find a ",(0,s.jsx)(n.code,{children:"-stubs"})," package, but there's no non-stubs package, return an import error."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Try to find a non-stub package corresponding to the import we're trying to resolve in ",(0,s.jsx)(n.code,{children:"site_package_path"}),".\nEntries earlier in the ",(0,s.jsx)(n.code,{children:"site_package_path"})," list will be selected before those appearing later in the list."]}),"\n",(0,s.jsx)(n.li,{children:"Return an import error."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"#site-package-path-typing-rules",children:"Site Package Path Typing Rules"})," for more information about which\nmodules are valid imports from ",(0,s.jsx)(n.a,{href:"/en/docs/configuration#site_package_path",children:(0,s.jsx)(n.code,{children:"site_package_path"})}),", and\nhow to override that behavior."]}),"\n",(0,s.jsx)(n.h3,{id:"site-package-path-typing-rules",children:"Site Package Path Typing Rules"}),"\n",(0,s.jsxs)(n.p,{children:["We respect typing rules as defined by the typing spec for\n",(0,s.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#stub-only-packages",children:"stubs packages"}),",\n",(0,s.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#partial-stub-packages",children:"partial stubs packages"}),",\nand ",(0,s.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#packaging-type-information",children:"py.typed"})," files.\nThat means:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["if we can find any ",(0,s.jsx)(n.code,{children:"-stubs"})," package, we do not fall back to non-stubs packages unless any of them contain a\n",(0,s.jsx)(n.code,{children:"py.typed"})," file in their top-level containing the content ",(0,s.jsx)(n.code,{children:"partial\\n"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["if we can't find any ",(0,s.jsx)(n.code,{children:"-stubs"})," packages, only accept a package's types if it contains a ",(0,s.jsx)(n.code,{children:"py.typed"})," file. Here,\nwe only check for the existence of the file, not for any contents."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can control the above behavior with the following two configs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/en/docs/configuration#use_untyped_imports",children:(0,s.jsx)(n.code,{children:"use_untyped_imports"})}),": don't worry about looking for any ",(0,s.jsx)(n.code,{children:"py.typed"}),"\nfile. Check for ",(0,s.jsx)(n.code,{children:"-stubs"})," first and fall back to non-stubs, regardless of the presence of a ",(0,s.jsx)(n.code,{children:"py.typed"})," with\n",(0,s.jsx)(n.code,{children:"partial\\n"})," or if the non-stubs packages contain a ",(0,s.jsx)(n.code,{children:"py.typed"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/en/docs/configuration#ignore_missing_source",children:(0,s.jsx)(n.code,{children:"ignore_missing_source"})}),": don't try to check for a backing non-stubs\npackage when we find a ",(0,s.jsx)(n.code,{children:"-stubs"})," package. Immediately return the ",(0,s.jsx)(n.code,{children:"-stubs"})," package when found."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"stub-files-vs-source-files",children:"Stub Files vs Source Files"}),"\n",(0,s.jsxs)(n.p,{children:["A\n",(0,s.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#stub-files",children:"stub file"}),"\nis any file that ends with a ",(0,s.jsx)(n.code,{children:".pyi"})," file suffix. They have many uses, including\nadding typing to non-Python extension code, distributing typing information\nseparate from implementation, or overriding an implementation with more accurate\ntyping information."]}),"\n",(0,s.jsxs)(n.p,{children:["A stub package is a second package corresponding to a regular package, with ",(0,s.jsx)(n.code,{children:"-stubs"}),"\nappended to its name. A ",(0,s.jsx)(n.code,{children:"-stubs"})," package should only include stub files (",(0,s.jsx)(n.code,{children:".pyi"}),"),\nwhich override any ",(0,s.jsx)(n.code,{children:".py"})," or ",(0,s.jsx)(n.code,{children:".pyi"})," files in the non-stubs package. These are preferred\nwhen available, since they contain the interfaces a library exposes to developers. An\nexample of this includes the popular library ",(0,s.jsx)(n.a,{href:"https://github.com/pandas-dev/pandas",children:(0,s.jsx)(n.code,{children:"pandas"})}),",\nand its stub package, ",(0,s.jsx)(n.a,{href:"https://github.com/pandas-dev/pandas-stubs",children:(0,s.jsx)(n.code,{children:"pandas-stubs"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When importing from a non-stubs package, Pyrefly loads typing information from\nimports by first searching for a relevant ",(0,s.jsx)(n.code,{children:"-stubs"})," package, then by looking at\nthe non-stubs package's ",(0,s.jsx)(n.code,{children:".pyi"})," files, then falls back to a ",(0,s.jsx)(n.code,{children:".py"})," file. See\n",(0,s.jsx)(n.a,{href:"#absolute-imports",children:"Absolute Imports"})," for details on when non-stubs packages\nare allowed to be used for types, and how you can override that behavior."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);