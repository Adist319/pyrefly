"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[3028],{83028:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>a,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"configuration","title":"Configuration","description":"Configure Pyrefly settings and options","source":"@site/docs/configuration.mdx","sourceDirName":".","slug":"/configuration","permalink":"/en/docs/configuration","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/pyrefly/edit/main/website/docs/configuration.mdx","tags":[],"version":"current","frontMatter":{"title":"Configuration","slug":"/configuration","description":"Configure Pyrefly settings and options"},"sidebar":"docsSidebar","previous":{"title":"Introduction","permalink":"/en/docs/category/introduction"},"next":{"title":"Learn Python Typing","permalink":"/en/docs/learn-python-typing"}}');var s=i(74848),o=i(28453);const l={title:"Configuration",slug:"/configuration",description:"Configure Pyrefly settings and options"},t="Pyrefly Configuration",c={},d=[{value:"Precedence in Options",id:"precedence-in-options",level:2},{value:"Configuration Finding",id:"configuration-finding",level:2},{value:"Configuration Options",id:"configuration-options",level:2},{value:"Environment Autoconfiguration",id:"environment-autoconfiguration",level:2},{value:"Module globbing",id:"module-globbing",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"pyrefly-configuration",children:"Pyrefly Configuration"})}),"\n",(0,s.jsx)(n.p,{children:"Pyrefly has a basic configuration that can (or will) allow you to customize your\nPyrefly runs without having to specify all of your arguments on the command\nline."}),"\n",(0,s.jsx)(n.p,{children:"NOTE: this is early in its development, so the options listed here are subject\nto change in name, usage, type, quantity, and structure."}),"\n",(0,s.jsxs)(n.p,{children:["Configurations can be specified in a ",(0,s.jsx)(n.a,{href:"https://toml.io/en/",children:"TOML file"})," at the root of\nyour project (or elsewhere, as long as the ",(0,s.jsx)(n.code,{children:"search_path"})," is correct) named\n",(0,s.jsx)(n.code,{children:"pyrefly.toml"}),", with all configuration options in the top-level of the document.\nYou can also specify a configuration in a ",(0,s.jsx)(n.code,{children:"pyproject.toml"})," under a ",(0,s.jsx)(n.code,{children:"[tool.pyrefly]"}),"\nsection. Other config names can be used when explicitly passing in the config file\nname with the ",(0,s.jsx)(n.code,{children:"--config"}),"/",(0,s.jsx)(n.code,{children:"-c"})," flag, but they will not be automatically found by\n",(0,s.jsx)(n.a,{href:"#configuration-finding",children:"Configuration Finding"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Both absolute and config-relative paths are supported."}),"\n",(0,s.jsx)(n.h2,{id:"precedence-in-options",children:"Precedence in Options"}),"\n",(0,s.jsx)(n.p,{children:"The following is the order in which configuration options are selected:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"CLI flag"}),"\n",(0,s.jsxs)(n.li,{children:["Environment variable override -- This is the same as ",(0,s.jsx)(n.code,{children:"PYREFLY_<CLI flag name>"})]}),"\n",(0,s.jsx)(n.li,{children:"Configuration option"}),"\n",(0,s.jsx)(n.li,{children:"Hard-coded default"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"configuration-finding",children:"Configuration Finding"}),"\n",(0,s.jsxs)(n.p,{children:["In both project checking mode (with no explicit configuration supplied) and\nsingle-file checking mode, we perform an upward file search to find a\nconfiguration file. We check each directory from the start location to the\nfilesystem root, looking first for ",(0,s.jsx)(n.code,{children:"pyrefly.toml"})," then ",(0,s.jsx)(n.code,{children:"pyproject.toml"}),", in\nthe same directory before looking at its parent."]}),"\n",(0,s.jsxs)(n.p,{children:["For project checking mode, the start location is the CWD. We do not perform any\nsearching if the ",(0,s.jsx)(n.code,{children:"--config"}),"/",(0,s.jsx)(n.code,{children:"-c"})," flag is used. For single-file checking mode,\nthe start location is the directory containing the file to be type checked. No\nconfig flag can be passed into Pyrefly in single file checking mode."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.code,{children:"pyrefly.toml"})," is found, it is parsed and used for type checking, and will\nreturn an error to the user on invalid types, syntax, or values."]}),"\n",(0,s.jsxs)(n.p,{children:["If a ",(0,s.jsx)(n.code,{children:"pyproject.toml"})," is found, Pyrefly will stop searching, even if no ",(0,s.jsx)(n.code,{children:"[tool.pyrefly]"}),"\nsection is found. The same errors will be returned as when loading a ",(0,s.jsx)(n.code,{children:"pyrefly.toml"})," if\nthe config is invalid."]}),"\n",(0,s.jsx)(n.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"project_includes"}),": the glob patterns used to describe which files to type\ncheck, typically understood as user-space files. This takes highest precedence\nin import resolution.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: list of Unix Glob patterns"}),"\n",(0,s.jsxs)(n.li,{children:["Default: ",(0,s.jsx)(n.code,{children:'["**/*.py", "**/*.pyi"]'})]}),"\n",(0,s.jsxs)(n.li,{children:["Flag equivalent: ",(0,s.jsx)(n.code,{children:"FILES..."})," argument"]}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent configs: ",(0,s.jsx)(n.code,{children:"include"})," in Pyright, ",(0,s.jsx)(n.code,{children:"files"}),"/",(0,s.jsx)(n.code,{children:"modules"}),"/",(0,s.jsx)(n.code,{children:"packages"})," in\nmypy"]}),"\n",(0,s.jsxs)(n.li,{children:["Notes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["When overridden by passing in ",(0,s.jsx)(n.code,{children:"FILES..."}),", we do not consult the\nrelevant config file for what to use for ",(0,s.jsx)(n.code,{children:"project_excludes"}),". If\n",(0,s.jsx)(n.code,{children:"project_excludes"})," should not use the default value, override it with the flag as\nwell."]}),"\n",(0,s.jsxs)(n.li,{children:["When a ",(0,s.jsx)(n.code,{children:"project_includes"})," pattern does not match any files, we will return\nan error."]}),"\n",(0,s.jsx)(n.li,{children:"If you get an error about no matches for a directory when passing a glob as a CLI\nargument, try wrapping the glob in quotes to prevent eager shell glob expansion."}),"\n",(0,s.jsxs)(n.li,{children:["We recognize the following wildcards:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*"}),", which matches zero or more characters in a single directory component"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"**"}),", which matches the current and any sub directories"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"?"}),", which matches any one character"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"project_excludes"}),": the glob patterns used to describe which files to avoid\ntype checking, usually as a more fine-grained way of controlling the files you\nget type errors on.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: list of Unix Glob patterns"}),"\n",(0,s.jsxs)(n.li,{children:["Default: ",(0,s.jsx)(n.code,{children:'["**/__pycache__/**", "**/.*"]'})]}),"\n",(0,s.jsxs)(n.li,{children:["Flag equivalent: ",(0,s.jsx)(n.code,{children:"--project-excludes"})]}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent configs: ",(0,s.jsx)(n.code,{children:"exclude"})," in Pyright and mypy"]}),"\n",(0,s.jsxs)(n.li,{children:["Notes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We match on these patterns, unlike ",(0,s.jsx)(n.code,{children:"project_includes"}),", where we\nenumerate all (Python) files under the directory. Because of this,\n",(0,s.jsx)(n.code,{children:"project_excludes"})," does not do directory matching unless a ",(0,s.jsx)(n.code,{children:"/"})," is added at\nthe end of your glob pattern. ",(0,s.jsx)(n.code,{children:"**/__pycache__/"})," will only match files under\na directory named ",(0,s.jsx)(n.code,{children:"__pycache__/"}),", but not a file named ",(0,s.jsx)(n.code,{children:"__pycache__"}),".\nLikewise, ",(0,s.jsx)(n.code,{children:"**/__pycache__"})," will only match files named ",(0,s.jsx)(n.code,{children:"__pycache__"}),", but\nnot files under a directory named ",(0,s.jsx)(n.code,{children:"__pycache__/"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["It is an error if no files are returned from any ",(0,s.jsx)(n.code,{children:"project_includes"})," because\nthey are filtered out by ",(0,s.jsx)(n.code,{children:"project_excludes"})," entries."]}),"\n",(0,s.jsxs)(n.li,{children:["When passing in ",(0,s.jsx)(n.code,{children:"FILES..."}),", we also do not consult the config file for\nwhat to use for ",(0,s.jsx)(n.code,{children:"project_excludes"}),". If ",(0,s.jsx)(n.code,{children:"project_excludes"})," should not use\nthe default value, override it with a flag as well."]}),"\n",(0,s.jsx)(n.li,{children:"If you get an error about no matches for a directory when passing a glob as a CLI\nargument, try wrapping the glob in quotes to prevent eager shell glob expansion."}),"\n",(0,s.jsxs)(n.li,{children:["We recognize the following wildcards:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*"}),", which matches zero or more characters in a single directory component"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"**"}),", which matches the current and any sub directories"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"?"}),", which matches any one character"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"search_path"}),": a file path describing a root from which imports should be\nfound and imported from (including modules in ",(0,s.jsx)(n.code,{children:"project_includes"}),"). This takes\nthe highest precedence in import order, before ",(0,s.jsx)(n.code,{children:"typeshed"})," and\n",(0,s.jsx)(n.code,{children:"site_package_path"}),". When a ",(0,s.jsx)(n.code,{children:"project_includes"})," type checked file is imported\nby another type checked file, we check all search roots to determine how to\nimport it.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: list of directories"}),"\n",(0,s.jsxs)(n.li,{children:["Default: ",(0,s.jsx)(n.code,{children:'["."]'})]}),"\n",(0,s.jsxs)(n.li,{children:["Flag equivalent: ",(0,s.jsx)(n.code,{children:"--search-path"})]}),"\n",(0,s.jsxs)(n.li,{children:["ENV equivalent: ",(0,s.jsx)(n.code,{children:"PYREFLY_SEARCH_PATH"})]}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent configs: ",(0,s.jsx)(n.code,{children:"extraPaths"})," in Pyright, ",(0,s.jsx)(n.code,{children:"mypy_path"})," in mypy"]}),"\n",(0,s.jsxs)(n.li,{children:["Notes: we automatically append ",(0,s.jsx)(n.code,{children:'"."'})," (the directory containing the\nconfiguration file) to the ",(0,s.jsx)(n.code,{children:"search_roots"})," when type checking as a sensible\ndefault and last attempt at an import."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"site_package_path"}),": a file path describing a root from which imports should\nbe found and imported from. This takes the lowest priority in import\nresolution, after ",(0,s.jsx)(n.code,{children:"project_includes"}),", ",(0,s.jsx)(n.code,{children:"typeshed"}),", and ",(0,s.jsx)(n.code,{children:"search_roots"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: list of directories"}),"\n",(0,s.jsxs)(n.li,{children:["Default: result from ",(0,s.jsx)(n.a,{href:"#environment-autoconfiguration",children:"Environment Autoconfiguration"})," or ",(0,s.jsx)(n.code,{children:"[]"})]}),"\n",(0,s.jsxs)(n.li,{children:["Flag equivalent: ",(0,s.jsx)(n.code,{children:"--site-package-path"})]}),"\n",(0,s.jsxs)(n.li,{children:["ENV equivalent: ",(0,s.jsx)(n.code,{children:"PYREFLY_SITE_PACKAGE_PATH"})]}),"\n",(0,s.jsx)(n.li,{children:"Equivalent configs: none"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"python_platform"}),": the value used with conditions based on type checking\nagainst\n",(0,s.jsx)(n.a,{href:"https://docs.python.org/3/library/sys.html#sys.platform",children:(0,s.jsx)(n.code,{children:"sys.platform"})}),"\nvalues.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: string"}),"\n",(0,s.jsxs)(n.li,{children:["Default: result from ",(0,s.jsx)(n.a,{href:"#environment-autoconfiguration",children:"Environment Autoconfiguration"}),' or "linux"']}),"\n",(0,s.jsxs)(n.li,{children:["Flag equivalent: ",(0,s.jsx)(n.code,{children:"--python-platform"})]}),"\n",(0,s.jsxs)(n.li,{children:["ENV equivalent: ",(0,s.jsx)(n.code,{children:"PYREFLY_PYTHON_PLATFORM"})]}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent configs: ",(0,s.jsx)(n.code,{children:"pythonPlatform"})," in Pyright, ",(0,s.jsx)(n.code,{children:"platform"})," in mypy"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"python_version"}),": the value used with conditions based on type checking\nagainst\n",(0,s.jsx)(n.a,{href:"https://docs.python.org/3/library/sys.html#sys.version",children:(0,s.jsx)(n.code,{children:"sys.version"})}),"\nvalues. The format should be ",(0,s.jsx)(n.code,{children:"<major>[.<minor>[.<micro>]]"}),", where minor and\nmicro can be omitted to take the default positional value.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: string"}),"\n",(0,s.jsxs)(n.li,{children:["Default: result from ",(0,s.jsx)(n.a,{href:"#environment-autoconfiguration",children:"Environment Autoconfiguration"})," or ",(0,s.jsx)(n.code,{children:"3.13.0"})]}),"\n",(0,s.jsxs)(n.li,{children:["Flag equivalent: ",(0,s.jsx)(n.code,{children:"--python-version"})]}),"\n",(0,s.jsxs)(n.li,{children:["ENV equivalent: ",(0,s.jsx)(n.code,{children:"PYREFLY_PYTHON_VERSION"})]}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent configs: ",(0,s.jsx)(n.code,{children:"pythonVersion"})," in Pyright, ",(0,s.jsx)(n.code,{children:"python_version"})," in mypy"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"python_interpreter"}),": the Python interpreter to query when attempting to autoconfigure\nPython environment values (",(0,s.jsx)(n.code,{children:"site_package_path"}),", ",(0,s.jsx)(n.code,{children:"python_platform"}),", ",(0,s.jsx)(n.code,{children:"python_version"}),").\nSee the ",(0,s.jsx)(n.a,{href:"#environment-autoconfiguration",children:"Environment Autoconfiguration section"})," for more information.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: string of executable or path to executable"}),"\n",(0,s.jsxs)(n.li,{children:["Default: ",(0,s.jsx)(n.code,{children:"python3"})]}),"\n",(0,s.jsxs)(n.li,{children:["Flag equivalent: ",(0,s.jsx)(n.code,{children:"--python-interpreter"})]}),"\n",(0,s.jsxs)(n.li,{children:["ENV equivalent: ",(0,s.jsx)(n.code,{children:"PYREFLY_PYTHON_INTERPRETER"})]}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent configs: ",(0,s.jsx)(n.code,{children:"python_executable"})," in mypy"]}),"\n",(0,s.jsxs)(n.li,{children:["Notes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["This executes the value present in the ",(0,s.jsx)(n.code,{children:"python_interpreter"})," field without any checks. It could\nbe a security risk if your ",(0,s.jsx)(n.code,{children:"python_interpreter"})," executes an arbitrary executable."]}),"\n",(0,s.jsxs)(n.li,{children:["If you are working on a project shared between multiple people, it is likely best not to use this\noption, since there might be different Python interpreter versions used on different systems. Instead,\nwe recommend explicitly setting ",(0,s.jsx)(n.code,{children:"python_version"}),", ",(0,s.jsx)(n.code,{children:"python_platform"}),", and ",(0,s.jsx)(n.code,{children:"site_package_path"}),", or using\nalternative methods of environment autoconfiguration (coming soon)."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"errors"}),": configure (enable and disable) the errors Pyrefly shows","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: Table of error code name to boolean representing enabled status"}),"\n",(0,s.jsxs)(n.li,{children:["Default: ",(0,s.jsx)(n.code,{children:"errors = {}"})]}),"\n",(0,s.jsx)(n.li,{children:"Flag equivalent: none"}),"\n",(0,s.jsx)(n.li,{children:"ENV equivalent: none"}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent configs:\n",(0,s.jsx)(n.a,{href:"https://microsoft.github.io/pyright/#/configuration?id=type-check-rule-overrides",children:"type check rule overrides"}),"\nand ",(0,s.jsx)(n.a,{href:"https://microsoft.github.io/pyright/#/configuration?id=type-evaluation-settings",children:"type evaluation settings"}),"\nin Pyright,\n",(0,s.jsx)(n.a,{href:"https://mypy.readthedocs.io/en/stable/config_file.html#confval-enable_error_code",children:(0,s.jsx)(n.code,{children:"enable_error_code"})})," and\n",(0,s.jsx)(n.a,{href:"https://mypy.readthedocs.io/en/stable/config_file.html#confval-disable_error_code",children:(0,s.jsx)(n.code,{children:"disable_error_code"})}),"\nin mypy"]}),"\n",(0,s.jsxs)(n.li,{children:["Notes: setting ",(0,s.jsx)(n.code,{children:"<error-code> = true"})," is the same as having no error code configuration present, which means\nthe error will be shown. Setting ",(0,s.jsx)(n.code,{children:"<error-code> = false"})," will disable the error for type checking."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"replace_imports_with_any"}),": ",(0,s.jsx)(n.a,{href:"#module-globbing",children:(0,s.jsx)(n.code,{children:"ModuleGlob"})}),"s of modules from which import errors should be\nignored, and the module should be replaced with ",(0,s.jsx)(n.code,{children:"typing.Any"}),". For example, with\n",(0,s.jsx)(n.code,{children:"from x.y import z"})," in a file, adding ",(0,s.jsx)(n.code,{children:"x.*"}),", ",(0,s.jsx)(n.code,{children:"*.y"}),", or ",(0,s.jsx)(n.code,{children:"x.y"})," to this config will\nsilence those import errors and replace the module with ",(0,s.jsx)(n.code,{children:"typing.Any"}),". If the module can be found, its type\ninformation will still be replaced with ",(0,s.jsx)(n.code,{children:"typing.Any"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: list of regex"}),"\n",(0,s.jsxs)(n.li,{children:["Default: ",(0,s.jsx)(n.code,{children:"[]"})]}),"\n",(0,s.jsx)(n.li,{children:"Flag equivalent: none"}),"\n",(0,s.jsx)(n.li,{children:"ENV equivalent: none"}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent configs: ",(0,s.jsx)(n.code,{children:"ignore_missing_imports"})," in mypy"]}),"\n",(0,s.jsxs)(n.li,{children:["Notes:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"errors = {import-error = false}"})," (TOML inline table for ",(0,s.jsx)(n.code,{children:"errors"}),") has similar behavior in Pyrefly, but ignores\n",(0,s.jsx)(n.em,{children:"all"})," import errors instead of import errors from specific modules, and won't replace findable modules with ",(0,s.jsx)(n.code,{children:"typing.Any"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ignore_errors_in_generated_code"}),": whether to ignore type errors in generated code. If enabled, generated files\nwill be treated as if they are included in ",(0,s.jsx)(n.code,{children:"project_excludes"}),".\nGenerated code are determined by checking if the file contents contain the substring ",(0,s.jsx)(n.code,{children:"{'@' + 'generated'}"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: bool"}),"\n",(0,s.jsx)(n.li,{children:"Default: false"}),"\n",(0,s.jsxs)(n.li,{children:["Flag equivalent: ",(0,s.jsx)(n.code,{children:"--ignore-errors-in-generated-code"})]}),"\n",(0,s.jsxs)(n.li,{children:["ENV equivalent: ",(0,s.jsx)(n.code,{children:"IGNORE_ERRORS_IN_GENERATED_CODE"})]}),"\n",(0,s.jsx)(n.li,{children:"Equivalent configs: none"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"use_untyped_imports"}),": whether to search imports in ",(0,s.jsx)(n.code,{children:"site_package_path"})," that do not have a ",(0,s.jsx)(n.code,{children:"py.typed"})," unconditionally.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Type: bool"}),"\n",(0,s.jsx)(n.li,{children:"Default: false"}),"\n",(0,s.jsx)(n.li,{children:"Flag equivalent: none"}),"\n",(0,s.jsxs)(n.li,{children:["ENV equivalent: ",(0,s.jsx)(n.code,{children:"PYREFLY_USE_UNTYPED_IMPORTS"})]}),"\n",(0,s.jsxs)(n.li,{children:["Equivalent configs: ",(0,s.jsx)(n.code,{children:"useLibraryCodeForTypes"})," in Pyright, ",(0,s.jsx)(n.code,{children:"follow_untyped_imports"})," in mypy"]}),"\n",(0,s.jsxs)(n.li,{children:["Notes: if a ",(0,s.jsx)(n.code,{children:"<library>-stubs"})," package exists in ",(0,s.jsx)(n.code,{children:"site_package_path"}),", we will search that first. If an import can't be\nfound, we only fall back to a regular ",(0,s.jsx)(n.code,{children:"<library>"})," package if no relevant ",(0,s.jsx)(n.code,{children:"-stubs"})," package exists, or any package contains a\n",(0,s.jsx)(n.code,{children:"py.typed"})," file with ",(0,s.jsx)(n.code,{children:"partial\\n"})," in accordance with\n",(0,s.jsx)(n.a,{href:"https://typing.python.org/en/latest/spec/distributing.html#partial-stub-packages",children:"the typing spec"}),". For all non-",(0,s.jsx)(n.code,{children:"-stubs"}),"\npackages, a ",(0,s.jsx)(n.code,{children:"py.typed"})," file is required to use the types, unless a ",(0,s.jsx)(n.code,{children:"-stubs"})," package specifies partial, or\n",(0,s.jsx)(n.code,{children:"use_untyped_imports"})," is true."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"environment-autoconfiguration",children:"Environment Autoconfiguration"}),"\n",(0,s.jsxs)(n.p,{children:["If any of ",(0,s.jsx)(n.code,{children:"python_platform"}),", ",(0,s.jsx)(n.code,{children:"python_version"}),", or ",(0,s.jsx)(n.code,{children:"site_package_path"})," are empty, we attempt to query an interpreter\nfor the missing values. By default we query ",(0,s.jsx)(n.code,{children:"python3"})," if it's available on the path, but the interpreter can be\noverridden with the ",(0,s.jsx)(n.code,{children:"python_interpreter"})," config option and flag. If the interpreter does not exist, we fall back to\nPyrefly's defaults for all unspecified values."]}),"\n",(0,s.jsx)(n.p,{children:"The values queried from the interpreter are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"python_platform"}),": ",(0,s.jsx)(n.code,{children:"sys.platform"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"python_version"}),": ",(0,s.jsx)(n.code,{children:"sys.version_info[:3]"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"site_package_path"}),": ",(0,s.jsx)(n.code,{children:"site.getsitepackages()"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"module-globbing",children:"Module globbing"}),"\n",(0,s.jsxs)(n.p,{children:["In some functionality, we've added globbing for module paths. This is different from both path globs and regex,\nin the sense that we're performing a match on a Python dotted import, such as ",(0,s.jsx)(n.code,{children:"this.is.any.module"}),".\nThe only wildcard we recognize is ",(0,s.jsx)(n.code,{children:"*"}),", which represents zero or more segments of a module path, unless it starts a glob,\nin which case it must match one or more segments. The wildcard must be surrounded\nby ",(0,s.jsx)(n.code,{children:"."}),", unless it is at the start or end of a module glob."]}),"\n",(0,s.jsx)(n.p,{children:"Examples:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"this.is.a.module"})," would be equivalent to a regex like ",(0,s.jsx)(n.code,{children:"^this\\.is\\.a\\.module"}),". It will only match imports that look like\n",(0,s.jsx)(n.code,{children:"this.is.a.module"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"this.is.*.module"})," would become ",(0,s.jsx)(n.code,{children:"^this\\.is(\\..+)*\\.module$"}),". It would match:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"this.is.module"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"this.is.a.module"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"this.is.a.really.long.path.to.a.module"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*.my.module"})," would be equivalent to a regex like ",(0,s.jsx)(n.code,{children:"^.+\\.my\\.module$"}),".","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["It would match:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"this.is.my.module"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"heres.my.module"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["It will not match:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"my.module"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"this.is.*"})," would be equivalent to a regex like ",(0,s.jsx)(n.code,{children:"^this\\.is(\\..+)*"}),". It would match:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"this.is.my.module"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"this.is"})}),"\n"]}),"\n"]}),"\n"]})]})}function a(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}}}]);